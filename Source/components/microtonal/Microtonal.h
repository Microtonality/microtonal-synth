#include <string>
using namespace std;
/* Contains the mapped frequency and its index relative to the list of all frequencies in a division */
class Mapping {
public:
    int index = NULL;
    double frequency = NULL;
};

/* Microtonal class containing configuration save/load methods, the base frequency, total divisions, and a list of mapped frequencies */
class MicrotonalConfig {
public:
    double base_frequency;
    double divisions;
    Mapping frequencies[12];

    /* Default constructor */
    MicrotonalConfig() {
        this->base_frequency = 261.63;
        this->divisions = 12;
    };

    /* Pass base frequency and total divisions */
    MicrotonalConfig(double basef, double div) {
        this->base_frequency = basef;
        this->divisions = div;
    };

    /* Pass base frequency, total divisions, int array of indices for values, and length of int array */
    MicrotonalConfig(double basef, double div, int* indices, int length) {
        this->base_frequency = basef;
        this->divisions = div;
        vector<double> allFreq = this->getAllFrequencies();

        for (int i = 0; i < length; i++) {
            frequencies[i].frequency = allFreq[indices[i]];
            frequencies[i].index = indices[i];
        }
    };

    /* Pass base frequency, total divisions, double array of frequencies, and length of the double array */
    MicrotonalConfig(double basef, double div, double* f, int length) {
        this->base_frequency = basef;
        this->divisions = div;
        vector<double> allFreq = this->getAllFrequencies();

        for (int i = 0; i < length; i++) {
            frequencies[i].frequency = f[i];
            frequencies[i].index = getIndex(allFreq, f[i]);
        }
    };

    /*
      * Description: Used in constructor to to find the location to map a frequency
      * Is generated by JUCE: No
      * Parameters: The list of all frequencies in a division and the frequency to search for
      * Return: Index if found, otherwise -1
    */
    int getIndex(vector<double> v, double K)
    {
        auto it = find(v.begin(), v.end(), K);

        if (it != v.end()){
            int index = it - v.begin();
            return index;
        }
        else return -1;
    }

    /*
      * Description: Checks if a frequency is connected to a key on the synth
      * Is generated by JUCE: No
      * Parameters: None
      * Return: true or false
    */
    bool isMapped() {
        for (Mapping m : frequencies) {
            if (m.frequency != NULL) return true;
        }

        return false;
    }

    /*
      * Description: Generates a list of all the frequencies in a division
      * Is generated by JUCE: No
      * Parameters: None
      * Return: A vector containing all the frequencies that can be mapped
    */
    vector<double> getAllFrequencies() {
        vector<double> freq;

		for (int i = 0; i <= divisions; i++) {
			double step_calc = (i / divisions);
			freq.push_back(base_frequency * pow(2, step_calc));
		}

        return freq;
    }

    /*
      * Description: Used to generate config file structure for saving and loading
      * Is generated by JUCE: No
      * Parameters: None
      * Return: A juce::ValueTree containing the base frequency, divisions, and list of mapped frequencies
    */
    juce::ValueTree generateValueTree() {
        juce::ValueTree t{"Preset"};
        t.setProperty("base_frequency", juce::String(base_frequency), nullptr);
        t.setProperty("total_divisions", juce::String(divisions), nullptr);

        for (int i = 0; i < 12; i++) {
            if (frequencies[i].frequency == NULL) continue;

            juce::ValueTree child{ "frequency" };
            child.setProperty("index", juce::String(i), nullptr);
            child.setProperty("value", juce::String(frequencies[i].frequency), nullptr);
            t.appendChild(child, nullptr);
        }
        
        return t;
    }
};
