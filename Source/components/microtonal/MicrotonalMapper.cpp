#include "MicrotonalMapper.h"
#include <math.h>
#include <iostream>
#include <fstream>
#include <regex>
using namespace std;

/* Program-wide variables */
MicrotonalConfig microtonalMappings[7];  // Stores the mappings that are used by the synth
extern juce::String microtonalPresetNames[7]; // Stores the mapping preset names to be displayed when a preset is loaded
atomic<int> mappingIndex; // Stores currently active mapping

/*
  * Description: Microtonal mapping window contructor
  * Is generated by JUCE: No
  * Parameters: The index for which mapping is being edited
  * Return: N/A
*/
MainContentComponent::MainContentComponent(int index) : synthAudioSource(keyboardState),
    keyboardComponent(keyboardState, juce::MidiKeyboardComponent::horizontalKeyboard)
{
        /* Set mapping preset number and total divisions of the octave*/
        this->index = index;
        divisions = (int)microtonalMappings[mappingIndex].divisions;
        mappingIndex = index;

        /* Render keyboard container on microtonal window */
        keyboardWindow.setColour(juce::TextButton::buttonColourId, juce::Colours::grey);
        keyboardWindow.setEnabled(false);
        keyboardWindow.setColour(juce::ComboBox::outlineColourId, juce::Colours::blue);
        addAndMakeVisible(keyboardWindow);

        /* Render total divisions input box */
        divisionInput.setFont(juce::Font(20.0f, juce::Font::bold));
        divisionInput.setText(to_string((int)microtonalMappings[mappingIndex].divisions), juce::dontSendNotification);
        divisionInput.setColour(juce::Label::textColourId, juce::Colours::black);
        divisionInput.setJustificationType(juce::Justification::centred);
        divisionInput.setEditable(true);
        divisionInput.setColour(juce::Label::backgroundColourId, colours[inputBackgroundColor]);
        divisionInput.setColour(juce::Label::outlineColourId, colours[inputOutlineTextColor]);
        divisionInput.onTextChange = [this] { 
            if (validateDivisionInput(divisionInput.getText())) {
                divisionInput.setText(divisionInput.getText(), juce::sendNotification);
                divisions = divisionInput.getText().getIntValue();
            }
            else {
                divisionInput.setText(juce::String(divisions), juce::dontSendNotification);
            }
        };
        divisionInput.setMouseCursor(juce::MouseCursor::IBeamCursor);
        addAndMakeVisible(divisionInput);

        /* Render total divisions label */
        divisionLabel.setFont(juce::Font(20.0f, juce::Font::bold));
        divisionLabel.setText("Notes per octave:", juce::dontSendNotification);
        divisionLabel.attachToComponent(&divisionInput, true);
        divisionLabel.setColour(juce::Label::textColourId, colours[3]);
        divisionLabel.setColour(juce::Label::backgroundColourId, colours[backgroundColor]);
        divisionLabel.setColour(juce::Label::outlineColourId, colours[backgroundColor]);
        divisionLabel.setJustificationType(juce::Justification::centred);
        addAndMakeVisible(divisionLabel);

        /* Render base frequency input box */
        baseFreqInput.setFont(juce::Font(18.0f, juce::Font::bold));
        baseFreqInput.setText(to_string(microtonalMappings[mappingIndex].base_frequency), juce::dontSendNotification);
        baseFreqInput.setColour(juce::Label::textColourId, juce::Colours::black);
        baseFreqInput.setColour(juce::Label::outlineColourId, colours[inputOutlineTextColor]);
        baseFreqInput.setColour(juce::Label::backgroundColourId, colours[inputBackgroundColor]);
        baseFreqInput.setJustificationType(juce::Justification::centred);
        baseFreqInput.setEditable(true);
        baseFreqInput.onTextChange = [this] {
            if (validateFrequencyInput(baseFreqInput.getText())) {
                baseFreqInput.setText(baseFreqInput.getText(), juce::sendNotification);
                frequency = baseFreqInput.getText().getDoubleValue();
            }
            else {
                baseFreqInput.setText(juce::String(frequency), juce::dontSendNotification);
            }
        };
        baseFreqInput.setMouseCursor(juce::MouseCursor::IBeamCursor);
        addAndMakeVisible(baseFreqInput);

        /* Remder base frequency label */
        baseFreqLabel.setFont(juce::Font(20.0f, juce::Font::bold));
        baseFreqLabel.setText("Base Frequency:", juce::dontSendNotification);
        baseFreqLabel.attachToComponent(&baseFreqInput, true);
        baseFreqLabel.setColour(juce::Label::textColourId, colours[inputOutlineTextColor]);
        baseFreqLabel.setColour(juce::Label::backgroundColourId, colours[backgroundColor]);
        baseFreqLabel.setColour(juce::Label::outlineColourId, colours[backgroundColor]);
        baseFreqLabel.setJustificationType(juce::Justification::centred);
        addAndMakeVisible(baseFreqLabel);

        /* Render generate button for frequencies */
        generateFrequencies.setColour(juce::TextButton::buttonColourId, colours[inputBackgroundColor]);
        generateFrequencies.setColour(juce::TextButton::textColourOffId, colours[inputOutlineTextColor]);
        generateFrequencies.setButtonText("Generate");
        generateFrequencies.addListener(this);
        generateFrequencies.setMouseCursor(juce::MouseCursor::PointingHandCursor);
        addAndMakeVisible(generateFrequencies);

        /* Render keyboard and enable sound */
        addAndMakeVisible(keyboardComponent);
        setAudioChannels(0, 2);
        setSize (1200, 800);
        startTimer (400);

        /* Render mapping and frequency buttons above the keyboard keys */
        for (auto& btn : noteButtons) {
            btn.setColour(juce::TextButton::buttonColourId, juce::Colours::blue);
            btn.setMouseCursor(juce::MouseCursor::PointingHandCursor);
            addAndMakeVisible(btn);
        }
        genFreqFunc();

        /* Render quick map input box */
        shortHandInput.setFont(juce::Font(20.0f, juce::Font::bold));
        shortHandInput.setColour(juce::Label::textColourId, juce::Colours::black);
        shortHandInput.setJustificationType(juce::Justification::centred);
        shortHandInput.setEditable(true);
        shortHandInput.setColour(juce::Label::backgroundColourId, colours[inputBackgroundColor]);
        shortHandInput.setColour(juce::Label::outlineColourId, colours[inputOutlineTextColor]);
        shortHandInput.setMouseCursor(juce::MouseCursor::IBeamCursor);
        addAndMakeVisible(shortHandInput);

        /* Render quick map button */
        shortHandBtn.setColour(juce::TextButton::buttonColourId, colours[inputBackgroundColor]);
        shortHandBtn.setColour(juce::TextButton::textColourOffId, colours[inputOutlineTextColor]);
        shortHandBtn.setButtonText("Quick Map");
        shortHandBtn.addListener(this);        
        shortHandBtn.setMouseCursor(juce::MouseCursor::PointingHandCursor);
        addAndMakeVisible(shortHandBtn);

        /* Render save mapping button */
        savePreset.setColour(juce::TextButton::buttonColourId, colours[inputBackgroundColor]);
        savePreset.setColour(juce::TextButton::textColourOffId, colours[inputOutlineTextColor]);
        savePreset.setButtonText("Save Mapping");
        savePreset.addListener(this);
        savePreset.setMouseCursor(juce::MouseCursor::PointingHandCursor);
        addAndMakeVisible(savePreset);
}
/*
  * Description: Destructor for stopping audio
  * Is generated by JUCE: Yes
  * Parameters: None
  * Return: N/A
*/
MainContentComponent::~MainContentComponent()
{
    shutdownAudio();
}

/*
  * Description: Used to update the state of the application when the window size changes
  * Is generated by JUCE: No
  * Parameters: None
  * Return: N/A
*/
void MainContentComponent::resized()
{
        /* Set main window bounds */
        divisions = (int)microtonalMappings[mappingIndex].divisions;
        auto area = getLocalBounds();
        auto upperWindowArea = area.removeFromTop(getHeight());
        upperWindow.setBounds(upperWindowArea);

        /* Set keyboard container bounds */
        auto keyboardWindowHeight = upperWindowArea.getHeight() * 0.6;
        auto keyboardWindowWidth = upperWindowArea.getWidth() * (6.0/7.0);
        auto keyboardWindowMargin = 10;
        auto keyboardWindowArea = upperWindowArea.removeFromBottom(keyboardWindowHeight).reduced(keyboardWindowMargin);
        keyboardWindow.setBounds(keyboardWindowArea);

        /* Set keyboard bounds */
        auto keyboardMargin = 10;
        auto keyboardWidthDelta = 0.2 * keyboardWindowArea.getWidth();
        auto keyboardHeightDelta = 0.1 * keyboardWindowArea.getHeight();
        auto keyboardArea = keyboardWindowArea.reduced(keyboardWidthDelta, keyboardHeightDelta);//.removeFromLeft(keyboardWidth);
        keyboardComponent.setBounds(keyboardArea);
        keyboardComponent.setKeyWidth(keyboardArea.getWidth() / 7.0);
        keyboardComponent.setAvailableRange(72, 83);

        /* Set total division label and input bounds */
        auto divisionHeight = keyboardWindow.getHeight() / 4;
        auto divisionWidth = keyboardWindow.getWidth() / 10;
        auto divisionMargin = 10;
        divisionInput.setBounds(keyboardWindow.getX() + divisionWidth + divisionMargin, keyboardWindow.getY() + divisionMargin, divisionWidth / 2, divisionHeight);//divisionInput.setBounds(keyboardWindow.getX(), keyboardWindow.getY(), divisionWidth, divisionHeight);
        divisionLabel.setBounds(keyboardWindow.getX() + divisionMargin, keyboardWindow.getY() + divisionMargin, divisionWidth, divisionHeight);
        
        /* Set base frequency label and input bounds */
        auto frequencyHeight = divisionHeight;
        auto frequencyWidth = divisionWidth;
        baseFreqInput.setBounds(keyboardWindow.getX() + frequencyWidth + divisionMargin, keyboardWindow.getY() + frequencyHeight + divisionMargin, frequencyWidth / 2, frequencyHeight);//baseFreqInput.setBounds(keyboardWindow.getX(), keyboardWindow.getY() + keyboardWindow.getHeight() - frequencyHeight, frequencyWidth, frequencyHeight);//baseFreqInput.setBounds(upperWindow.getX() + 200, upperWindow.getY() + 80, frequencyWidth, frequencyHeight);
        baseFreqLabel.setBounds(keyboardWindow.getX() + divisionMargin, keyboardWindow.getY() + frequencyHeight + divisionMargin, frequencyWidth, frequencyHeight);

        /* Set bounds for Generate button, Quick Map input/button, and Save Mapping button */
        int boxHeight = divisionInput.getWidth()*0.70;
        int boxWidth = boxHeight + 5;
        generateFrequencies.setBounds(keyboardWindow.getX() + divisionMargin, keyboardWindow.getY() + 2*frequencyHeight + divisionMargin, (3.0/2)*frequencyWidth, frequencyHeight);
        shortHandBtn.setBounds(((keyboardWindow.getWidth() + 2 * keyboardWindowMargin) + (keyboardComponent.getX() + keyboardComponent.getWidth()))/2 - (3.0 / 4) * frequencyWidth, keyboardWindow.getY() + 2 * frequencyHeight + divisionMargin + 15, (3.0 / 2) * frequencyWidth, frequencyHeight);
        shortHandInput.setBounds(((keyboardWindow.getWidth() + 2 * keyboardWindowMargin) + (keyboardComponent.getX() + keyboardComponent.getWidth())) / 2 - (3.0 / 4) * frequencyWidth, keyboardWindow.getY() + 2 * frequencyHeight + divisionMargin - frequencyHeight/2 + 15, (3.0 / 2) * frequencyWidth, frequencyHeight / 2);
        savePreset.setBounds(((keyboardWindow.getWidth() + 2 * keyboardWindowMargin) + (keyboardComponent.getX() + keyboardComponent.getWidth())) / 2 - (3.0 / 4) * frequencyWidth, keyboardComponent.getY(), (3.0 / 2) * frequencyWidth, frequencyHeight);

        /* Set bounds for frequency buttons so they are centered */
        auto iter = 1;
        vector<double>positions;
        positions.push_back(keyboardWindow.getWidth() / 2 + boxWidth / 2 - 10);
        for (int i = 1; i < divisions; i++) {
            positions.push_back(positions[0] + iter * (i % 2 == 0 ? 1 : -1) * ((boxWidth + 2)));
            iter = i % 2 == 0 ? iter + 1 : iter;
        }
        sort(positions.begin(), positions.end());
        auto Y = upperWindow.getY() + (keyboardWindow.getHeight() * 2) / 10; //+ (generateFrequencies.getHeight() / 3);
        for (int i = 0; i < divisions; i++) {
            frequencyBoxes[i].setBounds(positions[i], Y, boxWidth, boxHeight);
            frequencyBoxes[i].getBestWidthForHeight(boxHeight);
        }

        /* Set bounds for buttons above the keys so they are aligned */
        for (int i = 0; i < 12; i++) {
            int boxWidth = (divisionInput.getWidth() *0.7) + 2;
            int X = keyboardComponent.getKeyStartPosition(startKey) + keyboardComponent.getX() + ((keyboardComponent.getKeyWidth() / 5) * 3 * i),
                Y = keyboardComponent.getY() - 35,
                width = (boxWidth / 3) * 2,
                height = width;
                noteButtons[i].setBounds(X, Y, width, height);
        }
}

/*
  * Description: Function called after a keyboard key is pressed
  * Is generated by JUCE: Yes
*/
void MainContentComponent::prepareToPlay(int samplesPerBlockExpected, double sampleRate) 
{
    synthAudioSource.prepareToPlay(samplesPerBlockExpected, sampleRate);
}

/*
  * Description: Used to round a double to a certain precision to see if two frequencies are the same note
  * Is generated by JUCE: No
  * Parameters: The frequency and amount of decimal precision
  * Return: The rounded value
*/
float MainContentComponent::roundoff(float value, unsigned char prec)
{
    float pow_10 = pow(10.0f, (float)prec);
    return round(value * pow_10) / pow_10;
}

/*
  * Description: Used to render objects and shapes on the microtonal window.  Can update the state of the application by calling repaint()
  * Is generated by JUCE: No
  * Parameters: The graphics container
  * Return: N/A
*/
void MainContentComponent::paint(juce::Graphics& g) {
    /* Changes the color of the frequency boxes and draws a line connecting them to the keyboard keys */
    for (int i = 0; i < frequencies.size(); i++) {
        for (int j = 0; j < 12; j++) {
            if (roundoff(frequencies[i], 1) == roundoff(microtonalMappings[mappingIndex].frequencies[j].frequency, 1)) {
                float startX = frequencyBoxes[i].getX() + (frequencyBoxes[i].getWidth() / 2),
                    startY = frequencyBoxes[i].getY() + frequencyBoxes[i].getHeight(),
                    endX = noteButtons[j].getX() + (noteButtons[j].getWidth() / 2),
                    endY = noteButtons[j].getY();

                juce::Line<float> line(juce::Point<float>(startX,startY), juce::Point<float>(endX,endY));
                g.setColour(freqColors[j]);
                g.drawLine(line, 3.0f);
                frequencyBoxes[i].setColour(juce::TextButton::buttonColourId, freqColors[j]);
            }
        }
    }
}

/*
  * Description: Function called after a keyboard key is pressed
  * Is generated by JUCE: Yes
*/
void MainContentComponent::getNextAudioBlock(const juce::AudioSourceChannelInfo& bufferToFill) 
{
    synthAudioSource.getNextAudioBlock(bufferToFill);
}

/*
  * Description: Function called after a keyboard key is released
  * Is generated by JUCE: Yes
*/
void MainContentComponent::releaseResources() 
{
    synthAudioSource.releaseResources();
}

/*
  * Description: Removes all frequency button colors
  * Is generated by JUCE: No
  * Parameters: None
  * Return: N/A
*/
void MainContentComponent::undoButtonHighlighting()
{
    for (auto& b : frequencyBoxes) {
        b.removeColour(juce::ComboBox::outlineColourId);
        b.setColour(juce::TextButton::buttonColourId, juce::Colours::white);
    }
}

/*
  * Description: This function is called automatically whenever a button is clicked to perform a certain action
  * Is generated by JUCE: No
  * Parameters: The button that was clicked
  * Return: N/A
*/
void MainContentComponent::buttonClicked(juce::Button* btn)
{
    for (int i = 0; i < 24; i++) {
        /* Generate frequencies button */
        if (btn == &generateFrequencies) {
            for (int i = 0; i < 12; i++) {
                microtonalMappings[mappingIndex].frequencies[i].frequency = NULL;
                microtonalMappings[mappingIndex].frequencies[i].index = NULL;
            }
            genFreqFunc(); 
            this->resized();
            return; 
        }

        /* A frequency box has been selected */
        else if (btn == &frequencyBoxes[i]) {
            if (freqBoxIndex != i) { 
                freqBoxIndex = i; undoButtonHighlighting(); 
                frequencyBoxes[i].setColour(juce::TextButton::buttonColourId, juce::Colours::yellow);
                frequencyBoxes[i].setColour(juce::ComboBox::outlineColourId, juce::Colours::black); 
                return; 
            }

        }

        /* A note button has been clicked to map to the previously selected frequency box */
        else if (btn == &noteButtons[i]) {
            if (freqBoxIndex == -1) return;
            if (microtonalMappings[mappingIndex].frequencies[i].frequency != NULL) {
                for (int j = 0; j < frequencies.size(); j++) {
                    if (frequencies[j] == microtonalMappings[mappingIndex].frequencies[i].frequency) {
                        frequencyBoxes[j].setColour(juce::TextButton::buttonColourId, juce::Colours::white);
                    }
                }
            }
            microtonalMappings[mappingIndex].frequencies[i].index = freqBoxIndex;
            microtonalMappings[mappingIndex].frequencies[i].frequency = frequencies[freqBoxIndex];
            for (int k = 0; k < 12; k++) {
                if (k == i) continue;
                
                if (microtonalMappings[mappingIndex].frequencies[k].frequency == microtonalMappings[mappingIndex].frequencies[i].frequency) microtonalMappings[mappingIndex].frequencies[k].frequency = NULL;
            }
            noteButtons[i].setColour(juce::TextButton::buttonColourId, freqColors[i]);
            frequencyBoxes[freqBoxIndex].setColour(juce::TextButton::buttonColourId, freqColors[i]);
            frequencyBoxes[freqBoxIndex].removeColour(juce::ComboBox::outlineColourId);
            freqBoxIndex = -1;
            repaint();
            return;
        }

        /* DEPRECATED */
        else if (btn == &saveToXMLBtn) {
            DBG(writeValuesToXML());
            return;
        }

        /* Quick map button is clicked */
        else if (btn == &shortHandBtn) {
            mappingShortcut(shortHandInput.getText().toStdString());
            return;
        }

        /* Save mapping button is clicked */
        else if (btn == &savePreset) {
            saveMicrotonalPreset(index);
            return;
        }
    }
}

/*
  * Description: Contains the logic for quick map to shortcut key mapping
  * Is generated by JUCE: No
  * Parameters: The input string of three numbers: starting index, finishing index, how many steps until next note
    * example: "0 11 2" would map every other note from the 1st note to the 12th note     
  * Return: N/A
*/
void MainContentComponent::mappingShortcut(string inputString) {
    if (inputString == "") return;
    if (!regex_match(inputString, regex("^\\s*\\d\\d?\\s+\\d\\d?\\s+\\d\\d?\\s*$"))) return;
    istringstream iss(inputString);

    string word;
    iss >> word;

    int start = stoi(word);
    iss >> word;

    int finish = stoi(word);
    iss >> word;

    int steps = stoi(word);
    int noteBlock = 0;

    if (start > finish) return;
    steps = steps == 0 ? 1 : steps;
    genFreqFunc();

    /* Clear mapping */
    for (int i = 0; i < 12; i++) {
        microtonalMappings[mappingIndex].frequencies[i].index = NULL;
        microtonalMappings[mappingIndex].frequencies[i].frequency = NULL;
    }

    /* Edge case for if steps is equal to 1, previously caused errors */
    if (steps == 1) {
        start = 0; finish = 11;

        for (int i = start; i <= finish; i += steps) {
            if (i >= microtonalMappings[mappingIndex].divisions) break;
            microtonalMappings[mappingIndex].frequencies[noteBlock].index = noteBlock;
            microtonalMappings[mappingIndex].frequencies[noteBlock].frequency = frequencies[i];
            noteBlock++;
        }
    }

    /* Map frequencies based on input string */
    else {
        for (int i = start; i <= finish; i += steps, noteBlock++) {
            if (i >= microtonalMappings[mappingIndex].divisions) break;
            microtonalMappings[mappingIndex].frequencies[noteBlock].index = noteBlock;
            microtonalMappings[mappingIndex].frequencies[noteBlock].frequency = frequencies[i];
        }
    }

    /* Add color and connecting lines to new mapping */
    repaint();
}

/*
  * Description: Renders and activates frequency buttons dynamically.  Activates note buttons.
  * Is generated by JUCE: No
  * Parameters: None
  * Return: N/A
*/
void MainContentComponent::genFreqFunc() {
    /* Store mapping variables */
    microtonalMappings[mappingIndex].divisions = divisionInput.getText().getDoubleValue();
    microtonalMappings[mappingIndex].base_frequency = baseFreqInput.getText().getDoubleValue();
    frequencies = microtonalMappings[mappingIndex].getAllFrequencies();

    /* Render frequency boxes */
    for (int i = 0; i < microtonalMappings[mappingIndex].divisions; i++) {
        frequencyBoxes[i].setButtonText(to_string(frequencies[i]).substr(0, 5));
        frequencyBoxes[i].setColour(juce::TextButton::buttonColourId, juce::Colours::white);
        frequencyBoxes[i].setColour(juce::TextButton::textColourOffId, juce::Colours::black);
        frequencyBoxes[i].addListener(this);
        frequencyBoxes[i].setMouseCursor(juce::MouseCursor::PointingHandCursor);
        addAndMakeVisible(frequencyBoxes[i]);
    } 

    /* Render buttons above keyboard keys */
    for (int i = 0; i < 12; i++) {
        noteButtons[i].setColour(juce::TextButton::buttonColourId, freqColors[i]);
        noteButtons[i].setColour(juce::TextButton::textColourOffId, juce::Colours::black);
        noteButtons[i].addListener(this);
    }
    /* Deactivate and remove frequency buttons that are higher indices than the selected total divisions */
    for (int i = microtonalMappings[mappingIndex].divisions; i < 24; i++) {
        try{ 
            frequencyBoxes[i].setMouseCursor(juce::MouseCursor::NormalCursor);
            frequencyBoxes[i].setVisible(false); 
            frequencyBoxes[i].removeListener(this);
        }
        catch (const std::exception&){}
    }

    /* Add/remove color and connecting lines from frequency boxes */
    repaint();
}

/*
  * Description: Method of saving microtonal configuration to XML file
  * Is generated by JUCE: No
  * Parameters: None
  * Return: Microtonal config XML as string
  * CURRENTLY DEPRACATED
*/
string MainContentComponent::writeValuesToXML() {
    ofstream outf{ "../../Configs/previousState.xml" };
    if (!outf) { return "Error loading config."; }
    // juce::String writeToXML = microtonalMappings[mappingIndex].generateXML().toString();
    // outf << writeToXML;
    return NULL;
}

/*
  * Description: Used for handling incorrect input for total divisions input
  * Is generated by JUCE: No
  * Parameters: Total divisions inputted by user
  * Return: If the input is acceptable
*/
bool MainContentComponent::validateDivisionInput(const juce::String& s)
{
    return s.containsOnly("0123456789") && s.getIntValue() >= 12 && s.getIntValue() <= 24;
}

/*
  * Description: Used for handling incorrect input for base frequency input
  * Is generated by JUCE: No
  * Parameters: Base frequency inputted by user
  * Return: If the input is acceptable
*/
bool MainContentComponent::validateFrequencyInput(const juce::String& s)
{
    return s.getDoubleValue() >= 1 && s.getDoubleValue() <= 50000;
}

/*
  * Description: Used for updating the state of the application on a timer
  * Is generated by JUCE: No
  * Parameters: None
  * Return: N/A
*/
void MainContentComponent::timerCallback()
{
    keyboardComponent.grabKeyboardFocus();
    stopTimer();
}

/*
  * Description: Used for saving a microtonal preset to a file
  * Is generated by JUCE: No
  * Parameters: The index of which preset to save
  * Return: N/A
*/
void MainContentComponent::saveMicrotonalPreset(int preset) {
    // choose a file
    chooser = std::make_unique<juce::FileChooser>("Save a microtonal mapping preset", juce::File::getSpecialLocation(juce::File::SpecialLocationType::hostApplicationPath), "*xml", true, false);
    auto flags = juce::FileBrowserComponent::saveMode
        | juce::FileBrowserComponent::canSelectFiles
        | juce::FileBrowserComponent::warnAboutOverwriting;
    juce::String mapping = microtonalMappings[preset].generateValueTree().toXmlString();
    chooser->launchAsync(flags, [this, mapping, preset](const juce::FileChooser& fc) {
        if (fc.getResult() == juce::File{})
            return;
        juce::File myFile = fc.getResult().withFileExtension("xml");
        juce::String fileName = myFile.getFileName();
        microtonalPresetNames[preset] = fileName;
        /* Save file logic goes here*/
        if (!myFile.replaceWithText(mapping)) {
            juce::AlertWindow::showMessageBoxAsync(
                juce::AlertWindow::WarningIcon,
                TRANS("Error whilst saving"),
                TRANS("Couldn't write to the specified file!")
            );
        }
        /* End save file logic*/
        });
}
/*
  * Description: Methods for keyboard sound generation
  * Is generated by JUCE: Yes
*/
SynthAudioSource::SynthAudioSource(juce::MidiKeyboardState& keyState): keyboardState(keyState)
{
    for (auto i = 0; i < 4; ++i)                
        synth.addVoice(new SineWaveVoice());

    synth.addSound(new SineWaveSound());       
}
void SynthAudioSource::setUsingSineWaveSound()
{
    synth.clearSounds();
}
void SynthAudioSource::prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate) 
{
    synth.setCurrentPlaybackSampleRate(sampleRate); 
}
void SynthAudioSource::releaseResources() {}
void SynthAudioSource::getNextAudioBlock(const juce::AudioSourceChannelInfo& bufferToFill)
{
    bufferToFill.clearActiveBufferRegion();
    juce::MidiBuffer incomingMidi;

    keyboardState.processNextMidiBuffer(incomingMidi, bufferToFill.startSample,
        bufferToFill.numSamples, true);   

    synth.renderNextBlock(*bufferToFill.buffer, incomingMidi,
        bufferToFill.startSample, bufferToFill.numSamples);
}